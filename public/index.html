<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EMUDriverTraining — Markdown Viewer</title>
  <meta name="color-scheme" content="light dark" />
  <!-- 使用外部樣式（含樹狀縮排、連續直線、圓點與折疊） -->
  <link rel="stylesheet" href="/styles.css">
  <style>
    :root{
      /* 🔧 統一縮排參數 - 修改此值可調整所有層級的縮排 */
      --list-indent: 2.5rem;
      --h-sub-font-size: 18px;
      --h-sub-line-height: 1.65;
      --h-sub-font-weight: 600;
    }

    /* 針對圖片再加一點保護，確保不破壞縮排 */
    .section-body img{
      display:block;
      max-width:100%;
      height:auto;
      border-radius:8px;
      cursor: zoom-in;
      touch-action: manipulation;
    }
    .section-body li img{ margin-top:.25rem; }

    /* 🔧 關鍵修改：統一所有層級的清單縮排 */
    .section-body > ul,
    .section-body > ol{
      list-style-position: outside;
      padding-left: var(--list-indent) !important;
      margin-left: 0 !important;
    }
    
    .section-body ul ul,
    .section-body ul ol,
    .section-body ol ul,
    .section-body ol ol{
      padding-left: var(--list-indent) !important;
      list-style-position: outside;
      margin-left: 0 !important;
    }

    /* 清單項目本身不額外縮排 */
    .section-body li {
      padding-left: 0 !important;
    }

    /* 只包含一張圖片的清單項目：去圓點並回退一階 */
    .section-body li:has(> img:only-child),
    .section-body li:has(> p:only-child > img:only-child){
      list-style: none;
      padding-left: 0;
      margin-left: calc(-1 * var(--list-indent));
    }
    .section-body li.li-image-only{
      list-style: none;
      padding-left: 0;
      margin-left: calc(-1 * var(--list-indent));
    }

    /* 讓文字型清單字級 = h3~h6 */
    .section-body li.li-as-heading{
      font-size: var(--h-sub-font-size);
      line-height: var(--h-sub-line-height);
      font-weight: var(--h-sub-font-weight);
    }

    /* ===== 圖片全螢幕（overlay） ===== */
    .img-overlay{
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,.85);
      z-index: 1000;
      cursor: zoom-out;
      overflow: hidden;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }
    .img-overlay.open{ display: flex; }

    .img-overlay__viewport{
      position: relative;
      width: 95vw;
      height: 95vh;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      background: #000;
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0,0,0,.35);
    }

    .img-overlay__img{
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      will-change: transform;
      cursor: zoom-in;
    }
    .img-overlay__img.grabbable { cursor: grab; }
    .img-overlay__img.grabbing  { cursor: grabbing; }

    /* 讓偽 H7（role="heading"）在 section 樣式中被視為標題列 */
    .section > h2,
    .section > h3,
    .section > h4,
    .section > h5,
    .section > h6,
    .section > [role="heading"]{
      display:flex;
      align-items:center;
      column-gap:.5rem;
      margin: 0.35rem 0;
      min-height: 28px;
    }
    .section > h2::before,
    .section > h3::before,
    .section > h4::before,
    .section > h5::before,
    .section > h6::before,
    .section > [role="heading"]::before{
      content:"";
      flex:none;
      display:inline-block;
      width: var(--bullet-size);
      height: var(--bullet-size);
      border-radius: 50%;
      background: var(--bullet);
      margin-left: calc(-1 * (var(--gutter) - var(--bullet-size)) + 2px);
      margin-right: .35rem;
    }

    /* 非 section 包覆的偽 H7 樣式（比照 h3/h4 的排版） */
    .md-root :not(.section) > [role="heading"]{
      font-size: 18px;
      margin: 18px 0 8px;
      font-weight: 600;
      line-height: 1.5;
    }

    .section.no-rail::before{ display:none; }
  </style>
</head>
<body>
  <div class="wrap">
    <header class="hdr" style="display:none">
      <div class="brand">EMUDriverTraining</div>
      <div class="muted">Markdown Viewer（基礎版）</div>
    </header>

    <article class="card">
      <div class="titlebar" style="display:none">
        <h1 id="docTitle">Loading…</h1>
        <div class="meta" id="docMeta">—</div>
      </div>
      <div class="content">
        <div class="md-root" id="mdRoot"></div>
      </div>
    </article>
  </div>

  <!-- 放大用的 overlay（預先放在 DOM，透過 class 切換） -->
  <div class="img-overlay" id="imgOverlay" aria-hidden="true">
    <div class="img-overlay__viewport" id="imgViewport">
      <img class="img-overlay__img" id="imgOverlayImg" alt="">
    </div>
  </div>

  <script src="/lib/markdown-it.min.js"></script>
  <script>
  (function(){
    const MD_SRC  = '/content/index.md';
    const root    = document.getElementById('mdRoot');

    window.addEventListener('DOMContentLoaded', init);

    async function init(){
      if(typeof window.markdownit !== 'function'){
        return showError('找不到 markdown-it（/lib/markdown-it.min.js）。');
      }
      const md = window.markdownit({ html:false, linkify:true, typographer:true });

      try{
        const res  = await fetch(MD_SRC, { cache:'no-store' });
        if(!res.ok) throw new Error('HTTP '+res.status+' '+res.statusText);
        const text = await res.text();
        const { body } = parseFrontmatter(text);

        // 1) 渲染 Markdown
        root.innerHTML = md.render(body);

        // 2) 將 ./images/* 或 images/* 改寫到 /content/images/*
        rewriteRelativeImages(root);

        // 3) 把以 7 個以上 # 開頭的段落，升級成「偽 H7」
        promotePseudoHeadings(root);

        // 4) 標記「只含一張圖片」的 li（舊瀏覽器 fallback）
        markImageOnlyLis(root);

        // 5) 自動折疊（H2~H7），預設全部收合
        autoMakeCollapsible(root, { minLevel:2, maxLevel:7, defaultCollapsed:true });

        // 6) 統一 h3~h6（含偽 H7）的字級到 h2 的計算樣式
        unifyHeadingSizes(root);

        // 7) 把 h3~h6（含偽 H7）的字級抓出來寫到 CSS 變數，供清單共用
        captureHeadingTypography(root);

        // 8) 任何「非圖片-only」的清單，都用和副標題一致的字級
        tagHeadingSizedLis(root);

        // 9) 初次更新「是否要畫直線」（同層聯動）
        updateRailVisibility(root);

        // 10) 啟用圖片點擊全螢幕 + 滾輪縮放/拖曳
        enableImageFullscreen(root);
      }catch(err){
        showError('載入 Markdown 失敗：' + String(err));
        console.error(err);
      }
    }

    /* 將 ./images/* 或 images/* 改寫到 /content/images/* */
    function rewriteRelativeImages(container){
      const imgs = container.querySelectorAll('img');
      imgs.forEach(img=>{
        const src = img.getAttribute('src') || '';
        if (/^\/content\//i.test(src)) return;
        if (/^\.?\/?images\//i.test(src)) {
          const clean = src.replace(/^\.\//, '').replace(/^\/?images\//i, 'images/');
          img.setAttribute('src', '/content/' + clean);
        }
      });
    }

    /* 把以 7 個以上 # 開頭的段落轉成 偽 H7（role=heading, aria-level=7） */
    function promotePseudoHeadings(container){
      const paras = container.querySelectorAll('p');
      paras.forEach(p=>{
        const m = p.textContent.match(/^(#{7,})\s+(.+)$/);
        if(!m) return;
        const level = Math.min(m[1].length, 7); // 7 或以上都視為 7
        const text  = m[2].trim();

        const h = document.createElement('div');
        h.setAttribute('role', 'heading');
        h.setAttribute('aria-level', String(level));
        h.textContent = text;
        p.replaceWith(h);
      });
    }

    /* 標記只有一張圖片的 li，供舊瀏覽器使用（對齊 :has() 的條件） */
    function markImageOnlyLis(container){
      const lis = container.querySelectorAll('li');
      lis.forEach(li=>{
        const kids = Array.from(li.childNodes).filter(n => !(n.nodeType===3 && !n.textContent.trim()));
        let onlyImg = false;

        if(kids.length === 1 && kids[0].nodeType === 1){
          const el = kids[0];
          if(el.tagName === 'IMG'){
            onlyImg = true;
          }else if(el.tagName === 'P'){
            const pKids = Array.from(el.childNodes).filter(n => !(n.nodeType===3 && !n.textContent.trim()));
            if(pKids.length === 1 && pKids[0].nodeType === 1 && pKids[0].tagName === 'IMG'){
              onlyImg = true;
            }
          }
        }
        if(onlyImg) li.classList.add('li-image-only');
      });
    }

    /* 統一 h3~h6 與偽 H7 的字級為 h2 的計算樣式 */
    function unifyHeadingSizes(container){
      const probeH2 = container.querySelector('h2');
      if(!probeH2){ return; }
      const cs = getComputedStyle(probeH2);
      const fontSize   = cs.fontSize;
      const lineHeight = cs.lineHeight;
      const marginTop  = cs.marginTop;
      const marginBottom = cs.marginBottom;
      const fontWeight = cs.fontWeight;

      container.querySelectorAll('h3,h4,h5,h6,[role="heading"][aria-level]').forEach(h=>{
        h.style.fontSize   = fontSize;
        h.style.lineHeight = lineHeight;
        h.style.marginTop  = marginTop;
        h.style.marginBottom = marginBottom;
        h.style.fontWeight = fontWeight;
      });
    }

    /* 讀取任一個 h3（或 h2）作為清單字級來源 */
    function captureHeadingTypography(container){
      const ref = container.querySelector('h3,h4,h5,h6,[role="heading"][aria-level]') || container.querySelector('h2');
      if(!ref) return;
      const cs = getComputedStyle(ref);
      const root = document.documentElement;
      root.style.setProperty('--h-sub-font-size', cs.fontSize);
      root.style.setProperty('--h-sub-line-height', cs.lineHeight);
      root.style.setProperty('--h-sub-font-weight', cs.fontWeight);
    }

    /* 讓「非圖片-only」的 li 用 .li-as-heading 標記，套用副標題字級 */
    function tagHeadingSizedLis(container){
      const lis = container.querySelectorAll('.section-body li');
      lis.forEach(li=>{
        if(li.classList.contains('li-image-only')) return;
        li.classList.add('li-as-heading');
      });
    }

    /* 更新每個 section 的 "是否要畫直線"（no-rail）狀態
       同層只有一個 heading = 孤立 => .no-rail */
    function updateRailVisibility(container){
      const allSec = container.querySelectorAll('.section');
      allSec.forEach(sec=>{
        const lv = levelOf(sec.firstElementChild);
        const parent = sec.parentElement;
        const sibs = Array.from(parent.children).filter(el=>el.classList.contains('section'));
        const sameLv = sibs.filter(s=>{
          const h = s.firstElementChild;
          return h && levelOf(h)===lv;
        });
        const isAlone = (sameLv.length===1);
        sec.classList.toggle('no-rail', isAlone);
      });
    }

    /* 點擊圖片 -> overlay 全螢幕 + 滾輪縮放/拖曳 */
    function enableImageFullscreen(container){
      const overlay    = document.getElementById('imgOverlay');
      const viewport   = document.getElementById('imgViewport');
      const overlayImg = document.getElementById('imgOverlayImg');
      if(!overlay || !viewport || !overlayImg) return;

      let scale = 1, tx = 0, ty = 0;
      let dragging = false, lastX = 0, lastY = 0;
      let baseRect = null;
      const MIN_SCALE = 1, MAX_SCALE = 5;

      function calcBaseRect(){
        if(!overlayImg.complete) return null;
        const vpW = viewport.clientWidth;
        const vpH = viewport.clientHeight;
        const iW  = overlayImg.naturalWidth;
        const iH  = overlayImg.naturalHeight;
        const scaleW = vpW / iW;
        const scaleH = vpH / iH;
        const fitScale = Math.min(scaleW, scaleH, 1);
        return { width: iW * fitScale, height: iH * fitScale };
      }

      function applyTransform(){
        overlayImg.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
      }

      function resetTransform(){
        scale = 1; tx = 0; ty = 0;
        applyTransform();
        overlayImg.classList.remove('grabbable','grabbing');
        overlay.style.cursor = 'zoom-out';
      }

      function clampPan(){
        const vpW = viewport.clientWidth;
        const vpH = viewport.clientHeight;
        const imgW = baseRect ? baseRect.width  : overlayImg.getBoundingClientRect().width / scale;
        const imgH = baseRect ? baseRect.height : overlayImg.getBoundingClientRect().height / scale;

        const scaledW = imgW * scale;
        const scaledH = imgH * scale;

        const maxX = Math.max(0, (scaledW - vpW) / 2);
        const maxY = Math.max(0, (scaledH - vpH) / 2);

        if(maxX === 0) tx = 0; else tx = Math.max(-maxX, Math.min(maxX, tx));
        if(maxY === 0) ty = 0; else ty = Math.max(-maxY, Math.min(maxY, ty));
      }

      function zoomAt(clientX, clientY, deltaY){
        const zoomFactor = Math.exp(-deltaY * 0.002);
        const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * zoomFactor));
        if(newScale === scale) return;

        const vpRect = viewport.getBoundingClientRect();
        const offsetX = clientX - (vpRect.left + vpRect.width/2);
        const offsetY = clientY - (vpRect.top  + vpRect.height/2);

        const imgToCursorX = offsetX - tx;
        const imgToCursorY = offsetY - ty;

        const ratio = newScale / scale;
        tx = offsetX - imgToCursorX * ratio;
        ty = offsetY - imgToCursorY * ratio;

        scale = newScale;
        clampPan();
        applyTransform();

        if(scale > 1){
          overlayImg.classList.add('grabbable');
          overlay.style.cursor = 'default';
        }else{
          overlayImg.classList.remove('grabbable','grabbing');
          overlay.style.cursor = 'zoom-out';
        }
      }

      function openOverlay(img){
        overlayImg.src = img.currentSrc || img.src;
        overlayImg.alt = img.alt || '';
        overlay.classList.add('open');
        overlay.setAttribute('aria-hidden', 'false');
        document.body.style.overflow = 'hidden';

        if(overlayImg.complete){
          baseRect = calcBaseRect();
        }else{
          overlayImg.onload = ()=>{ baseRect = calcBaseRect(); };
        }
        resetTransform();
      }

      function closeOverlay(){
        overlay.classList.remove('open');
        overlay.setAttribute('aria-hidden', 'true');
        overlayImg.src = '';
        document.body.style.overflow = '';
      }

      container.addEventListener('click', (e)=>{
        const img = e.target.closest('img');
        if(!img) return;
        openOverlay(img);
      });

      overlay.addEventListener('click', (e)=>{
        if(e.target === overlay){
          closeOverlay();
        }
      });

      window.addEventListener('keydown', (e)=>{
        if(e.key === 'Escape' && overlay.classList.contains('open')){
          closeOverlay();
        }
      });

      overlay.addEventListener('wheel', (e)=>{
        e.preventDefault();
        const deltaY = e.deltaY * (e.ctrlKey ? 0.5 : 1);
        zoomAt(e.clientX, e.clientY, deltaY);
      }, { passive: false });

      overlayImg.addEventListener('dblclick', (e)=>{
        e.preventDefault();
        if(scale === 1){
          const fakeDelta = Math.log(2/scale)/(-0.002);
          zoomAt(e.clientX, e.clientY, fakeDelta);
        }else{
          resetTransform();
        }
      });

      overlayImg.addEventListener('pointerdown', (e)=>{
        if(scale <= 1) return;
        e.preventDefault();
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        overlayImg.setPointerCapture(e.pointerId);
        overlayImg.classList.add('grabbing');
      });
      overlayImg.addEventListener('pointermove', (e)=>{
        if(!dragging) return;
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX;
        lastY = e.clientY;
        tx += dx;
        ty += dy;
        clampPan();
        applyTransform();
      });
      const endDrag = (e)=>{
        if(!dragging) return;
        dragging = false;
        overlayImg.classList.remove('grabbing');
        try{ overlayImg.releasePointerCapture(e.pointerId); }catch(_){}
      };
      overlayImg.addEventListener('pointerup', endDrag);
      overlayImg.addEventListener('pointercancel', endDrag);
    }

    /* 自動折疊 + 設定縮排深度（H2~H7） */
    function autoMakeCollapsible(container, {minLevel=2, maxLevel=7, defaultCollapsed=false}={}){
      const headSel = 'h2,h3,h4,h5,h6,[role="heading"][aria-level]';
      const allHeads = Array.from(container.querySelectorAll(headSel));
      const headings = allHeads.filter(h => levelOf(h) >= minLevel && levelOf(h) <= maxLevel);

      for(let i = headings.length - 1; i >= 0; i--){
        const h = headings[i];
        if (h.parentElement && h.parentElement.classList.contains('section')) continue;

        const curLv  = levelOf(h);
        const depth  = Math.max(0, curLv - minLevel); // H2=0,... H7=5
        const bodyFrag = document.createDocumentFragment();
        let n = h.nextSibling;
        let hasChildHeading = false;

        while(n){
          const isEl = n.nodeType === 1;
          if (isEl && isHeadingEl(n)) {
            const lv = levelOf(n);
            if (lv <= curLv) break;
            if (lv > curLv) hasChildHeading = true;
          }
          if (isEl && n.classList.contains('section')) {
            const first = n.firstElementChild;
            if (first && isHeadingEl(first)) {
              const lv = levelOf(first);
              if (lv <= curLv) break;
              if (lv > curLv) hasChildHeading = true;
            }
          }
          const next = n.nextSibling;
          bodyFrag.appendChild(n);
          n = next;
        }

        const wrap = document.createElement('div');
        wrap.className = 'section';
        wrap.style.setProperty('--depth', depth);
        h.parentNode.insertBefore(wrap, h);
        wrap.appendChild(h);

        if(hasChildHeading || bodyFrag.childNodes.length){
          const body = document.createElement('div');
          body.className = 'section-body';
          body.appendChild(bodyFrag);
          wrap.appendChild(body);

          const key = 'fold:' + curLv + ':' + normalizeText(h.textContent);
          const saved = loadState(key);
          const startCollapsed = (saved != null) ? saved : !!defaultCollapsed;
          if(startCollapsed) body.classList.add('collapsed');

          const btn = document.createElement('button');
          btn.className = 'section-toggle';
          setToggleVisual(btn, body.classList.contains('collapsed'));
          btn.addEventListener('click', ()=>{
            const nextCollapsed = !body.classList.contains('collapsed');
            body.classList.toggle('collapsed', nextCollapsed);
            setToggleVisual(btn, nextCollapsed);
            saveState(key, nextCollapsed);
            updateRailVisibility(container);
          });
          h.insertBefore(btn, h.firstChild);
        }
      }
    }

    function setToggleVisual(btn, collapsed){
      btn.textContent = collapsed ? '▶' : '▼';
      btn.setAttribute('aria-expanded', String(!collapsed));
      btn.title = collapsed ? '展開' : '收合';
    }
    function isHeadingEl(el){
      if(!el) return false;
      if(el.tagName && /^H[2-6]$/.test(el.tagName)) return true;
      if(el.getAttribute && el.getAttribute('role') === 'heading'){
        const lv = parseInt(el.getAttribute('aria-level'), 10);
        return lv >= 2 && lv <= 7;
      }
      return false;
    }
    function levelOf(hEl){
      if(hEl.getAttribute && hEl.getAttribute('role') === 'heading'){
        const lv = parseInt(hEl.getAttribute('aria-level'), 10);
        if(Number.isFinite(lv)) return lv;
      }
      return parseInt(hEl.tagName.slice(1),10);
    }
    function normalizeText(s){ return (s||'').replace(/\s+/g,'').trim(); }

    /* Frontmatter 解析 */
    function parseFrontmatter(src){
      if(src.charCodeAt(0) === 0xFEFF) src = src.slice(1);
      const m = src.match(/^---\s*[\r\n]([\s\S]*?)\r?\n---\s*[\r\n]([\s\S]*)$/);
      if(m) return { meta: yamlToJSON(m[1]), body: m[2] };
      return { meta:{}, body: src };
    }
    function yamlToJSON(yaml){
      const out = {};
      yaml.split(/\r?\n/).forEach(line=>{
        if(!line.trim() || line.trim().startsWith('#')) return;
        const i = line.indexOf(':'); if(i<1) return;
        const k = line.slice(0,i).trim();
        let v = line.slice(i+1).trim();
        if((v.startsWith('"') && v.endsWith('"'))||(v.startsWith("'") && v.endsWith("'"))) v=v.slice(1,-1);
        out[k]=v;
      });
      return out;
    }

    /* 狀態保存 */
    function saveState(key, val){ try{ localStorage.setItem(key, JSON.stringify(!!val)); }catch(e){} }
    function loadState(key){
      try{
        const v = localStorage.getItem(key);
        return v==null ? null : JSON.parse(v);
      }catch(e){ return null; }
    }

    function showError(msg){
      root.innerHTML = '<pre style="white-space:pre-wrap;background:#0001;padding:12px;border-radius:8px">'+msg+'</pre>';
    }
  })();
  </script>
</body>
</html>