<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>客貨車駕駛人員班</title>

  <!-- ===== Icons / PWA ===== -->
  <!-- Favicon(一般桌面/Android 皆會用到) -->
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <!-- 傳統 .ico(相容性保險) -->
  <link rel="shortcut icon" href="/icons/favicon.ico">
  <!-- iOS 主畫面捷徑用 -->
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
  <!-- Web App Manifest(Android / Chrome PWA) -->
  <link rel="manifest" href="/icons/site.webmanifest">
  <!-- 狀態列顏色 -->
  <meta name="theme-color" content="#ffffff" id="theme-color-meta">
  <!-- iOS Safari(可選):啟用全螢幕樣式與狀態列色彩 -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <link rel="stylesheet" href="/styles.css">

  <!-- 主題模式控制腳本(必須在 head 最前面執行,避免閃爍) -->
  <script>
    (function(){
      const isDarkMode = window.location.pathname.includes('/dark');
      document.documentElement.setAttribute('data-theme', isDarkMode ? 'dark' : 'light');

      // 更新 theme-color meta
      const themeColorMeta = document.getElementById('theme-color-meta');
      if(themeColorMeta){
        themeColorMeta.setAttribute('content', isDarkMode ? '#0b0c0f' : '#ffffff');
      }
    })();
  </script>

  <style>
    :root{
      /* 清單字級(供 .section 標題與一般 li 使用) */
      --h-sub-font-size: 18px;
      --h-sub-line-height: 1.65;
      --h-sub-font-weight: 600;

      /* 內容最大寬度限制(可調整的百分比) */
      --content-max-width-percent: 70vw;

      /* 導引點尺寸與縮排(由外部 styles.css 補完) */
      --bullet-size: 10px;
      --gutter: 22px;
      --bullet-nudge-x: 0px;
      --indent: 22px;
      --bullet: currentColor;

      /* 可微調圓點垂直位置(相對第一行) */
      --bullet-nudge-y: 0px;

      /* 只針對第一層級圓點的額外垂直微調(正數=往下) */
      --bullet-nudge-y-l1: 10px;
    }

    /* 容器允許水平捲動 + 平滑捲動 + 左側 padding 作為 scrollIntoView 的對齊區 */
    .wrap {
      overflow-x: auto;
      overflow-y: auto;
      scroll-behavior: smooth;
      scroll-padding-left: 8px;
      padding-left: 8px;
    }

    /* 讓內容可以水平延伸 */
    .card { min-width: min-content; width: fit-content; }
    .content { min-width: min-content; width: fit-content; }
    .md-root { width: fit-content; max-width: none; }

    /* 內文圖片寬度限制 */
    .section-body img{
      display:block;
      max-width: var(--content-max-width-percent);
      height:auto;
      border-radius:8px;
      cursor: zoom-in;
      touch-action: manipulation;
    }
    .section-body li img{ margin-top:.25rem; }

    /* 文字內容限制 */
    .section-body p,
    .section-body > *:not(.section):not(ul):not(ol) {
      max-width: var(--content-max-width-percent);
      word-wrap: break-word;
      overflow-wrap: break-word;
      white-space: normal;
    }

    /* 只包含一張圖片的清單項目(去掉圓點並回補縮排) —— 舊瀏覽器 fallback(轉換前的 <li>) */
    .section-body li:has(> img:only-child),
    .section-body li:has(> p:only-child > img:only-child){
      list-style: none;
      padding-left: 0;
      margin-left: calc(-1 * var(--indent));
    }
    .section-body li.li-image-only{
      list-style: none;
      padding-left: 0;
      margin-left: calc(-1 * var(--indent));
    }

    /* 文字型清單字級 = 副標題 */
    .section-body li.li-as-heading{
      font-size: var(--h-sub-font-size);
      line-height: var(--h-sub-line-height);
      font-weight: var(--h-sub-font-weight);
      max-width: var(--content-max-width-percent);
      word-wrap: break-word;
    }

    /* ===== 圖片全螢幕(overlay) ===== */
    .img-overlay{
      position: fixed; inset: 0; display: none;
      align-items: center; justify-content: center;
      background: rgba(0,0,0,.85); z-index: 1000;
      cursor: zoom-out; overflow: hidden;
      -webkit-user-select: none; user-select: none; touch-action: none;
    }
    .img-overlay.open{ display: flex; }
    .img-overlay__viewport{
      position: relative; width: 95vw; height: 95vh;
      display: flex; align-items: center; justify-content: center;
      overflow: hidden; background: #000; border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0,0,0,.35);
      cursor: zoom-out;
    }
    .img-overlay__img{
      max-width: 100%; max-height: 100%; object-fit: contain;
      will-change: transform; cursor: zoom-in;
      touch-action: none;
    }
    .img-overlay__img.grabbable { cursor: grab; }
    .img-overlay__img.grabbing  { cursor: grabbing; }

    /* ===== 標題列(含圓點) —— 讓圓點鎖在第一行 ===== */
    .section > [role="heading"]{
      display:flex;
      align-items:flex-start; /* 以第一行的行盒頂端作為定位基準 */
      column-gap:.5rem;
      margin: 0.35rem 0; min-height: 28px;
      font-size: var(--h-sub-font-size);
      line-height: var(--h-sub-line-height);
      font-weight: var(--h-sub-font-weight);
      cursor: pointer;
      user-select: none;
      max-width: none;
      word-wrap: break-word;
      overflow-wrap: break-word;
      white-space: normal;
    }
    .section > [role="heading"]::before{
      content:""; flex:none; display:inline-block;
      width: var(--bullet-size); height: var(--bullet-size);
      border-radius: 50%;
      box-sizing: border-box;
      margin-left: calc(-1 * (var(--gutter) - var(--bullet-size)) + var(--bullet-nudge-x));
      margin-right: .35rem;

      /* 使圓點在「第一行」的行盒中垂直置中:
         第一行行高 = var(--h-sub-line-height) * 1em */
      margin-top: calc((var(--h-sub-line-height) * 1em - var(--bullet-size)) / 2 + var(--bullet-nudge-y, 0px));

      background: var(--bullet);
      border: 2px solid transparent;
      /* 注意:我們用 visibility 來隱藏(在 styles.css 控制),以保留佈局空間 */
    }
    .section.has-children > [role="heading"]::before{
      background: transparent;
      border-color: var(--bullet);
    }

    .section.no-rail::before{ display:none; }

    /* 只修正「第一層級」圓點的垂直置中微調(不影響其他層級) */
    .section[style*="--depth: 0"] > [role="heading"]::before{
      margin-top: calc(
        (var(--h-sub-line-height) * 1em - var(--bullet-size)) / 2
        + var(--bullet-nudge-y-l1, 1px)
      );
    }

    /* pre/code 也遵守寬度限制(在內文區) */
    .section-body pre,
    .section-body code {
      max-width: var(--content-max-width-percent);
      overflow-x: auto;
      word-wrap: break-word;
    }

    /* ===== 全部收合按鈕 ===== */
    .collapse-all-btn {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 999;
      padding: 8px 14px;
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(2px);
      border: 1px solid rgba(0, 0, 0, 0.05);
      border-radius: 8px;
      color: rgba(102, 102, 102, 0.4);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      user-select: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      transition: opacity 0.3s ease, transform 0.3s ease, background 0.2s ease, color 0.2s ease;
      opacity: 0;
      pointer-events: none;
      letter-spacing: 2px;
    }

    .collapse-all-btn.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .collapse-all-btn:hover {
      background: rgba(255, 255, 255, 0.6);
      color: rgba(102, 102, 102, 0.6);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    .collapse-all-btn:active {
      transform: translateY(0);
      background: rgba(122, 162, 255, 0.25);
      border-color: rgba(122, 162, 255, 0.3);
      color: rgba(122, 162, 255, 0.6);
    }

    @keyframes btnPulse {
      0% { box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05); }
      50% { box-shadow: 0 2px 16px rgba(122, 162, 255, 0.3); }
      100% { box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05); }
    }

    .collapse-all-btn.pulse {
      animation: btnPulse 0.3s ease;
    }

    /* 暗色模式按鈕樣式 */
    [data-theme="dark"] .collapse-all-btn {
      background: rgba(255, 255, 255, 0.4);
      color: rgba(200, 200, 200, 0.4);
      border-color: rgba(255, 255, 255, 0.05);
    }

    [data-theme="dark"] .collapse-all-btn:hover {
      background: rgba(255, 255, 255, 0.6);
      color: rgba(200, 200, 200, 0.6);
    }

    [data-theme="dark"] .collapse-all-btn:active {
      background: rgba(122, 162, 255, 0.25);
      color: rgba(122, 162, 255, 0.6);
    }
  </style>
</head>
<body>
  <!-- 全部收合按鈕 -->
  <button class="collapse-all-btn" id="collapseAllBtn">&gt; &lt;</button>

  <div class="wrap" id="mainWrap">
    <header class="hdr" style="display:none">
      <div class="brand">EMUDriverTraining</div>
      <div class="muted">Markdown Viewer(清單樹狀版)</div>
    </header>

    <article class="card">
      <div class="titlebar" style="display:none">
        <h1 id="docTitle">Loading…</h1>
        <div class="meta" id="docMeta">—</div>
      </div>
      <div class="content">
        <div class="md-root" id="mdRoot"></div>
      </div>
    </article>
  </div>

  <!-- 放大用 overlay -->
  <div class="img-overlay" id="imgOverlay" aria-hidden="true">
    <div class="img-overlay__viewport" id="imgViewport">
      <img class="img-overlay__img" id="imgOverlayImg" alt="">
    </div>
  </div>

  <script src="/lib/markdown-it.min.js"></script>
  <script>
  (function(){
    const MD_SRC   = '/content/index.md';
    const root     = document.getElementById('mdRoot');
    const mainWrap = document.getElementById('mainWrap');
    const collapseAllBtn = document.getElementById('collapseAllBtn');

    // 儲存收合前的狀態
    let savedStates = null;
    let isCollapsedAll = false;

    window.addEventListener('DOMContentLoaded', init);

    async function init(){
      if(typeof window.markdownit !== 'function'){
        return showError('找不到 markdown-it(/lib/markdown-it.min.js)。');
      }
      const md = window.markdownit({ html:false, linkify:true, typographer:true });

      try{
        const res  = await fetch(MD_SRC, { cache:'no-store' });
        if(!res.ok) throw new Error('HTTP '+res.status+' '+res.statusText);
        const text = await res.text();
        const { body } = parseFrontmatter(text);

        // 1) 渲染 Markdown
        root.innerHTML = md.render(body);

        // 2) 將 ./images/* 或 images/* 改寫到 /content/images/*
        rewriteRelativeImages(root);

        // 3) 將 <ul>/<ol> 的 <li> 轉成 .section(點標題展開/收合)
        listsToSections(root, { defaultCollapsed: true });

        // 4) 標記「只含一張圖片」與「一般文字型」的 li(舊瀏覽器 fallback)
        markImageOnlyLis(root);
        tagHeadingSizedLis(root);

        // 5) 更新導軌
        updateRailVisibility(root);

        // 6) 啟用圖片全螢幕
        enableImageFullscreen(root);

        // 7) 設定全部收合按鈕
        setupCollapseAllButton();
      }catch(err){
        showError('載入 Markdown 失敗:' + String(err));
        console.error(err);
      }
    }

    /* ===== 全部收合按鈕功能 ===== */
    function setupCollapseAllButton(){
      // 監聽滾動事件,在頂端時顯示按鈕
      let scrollTimeout;
      mainWrap.addEventListener('scroll', ()=>{
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(()=>{
          const isAtTop = mainWrap.scrollTop <= 10;
          collapseAllBtn.classList.toggle('visible', isAtTop);
        }, 50);
      });

      // 初始檢查
      const isAtTop = mainWrap.scrollTop <= 10;
      collapseAllBtn.classList.toggle('visible', isAtTop);

      // 按鈕點擊事件
      collapseAllBtn.addEventListener('click', ()=>{
        // 觸發脈衝動畫
        collapseAllBtn.classList.remove('pulse');
        void collapseAllBtn.offsetWidth;
        collapseAllBtn.classList.add('pulse');

        if(!isCollapsedAll){
          // 收合全部
          collapseAll();
          collapseAllBtn.innerHTML = '&lt; &gt;';
          isCollapsedAll = true;
        }else{
          // 恢復之前的狀態
          restoreAll();
          collapseAllBtn.innerHTML = '&gt; &lt;';
          isCollapsedAll = false;
        }
      });
    }

    function collapseAll(){
      // 儲存當前所有節點的狀態
      savedStates = new Map();
      const allSections = root.querySelectorAll('.section');

      allSections.forEach(section => {
        const body = section.querySelector('.section-body');
        const heading = section.querySelector('[role="heading"]');
        if(!body || !heading) return;

        const isExpanded = !body.classList.contains('collapsed');
        const key = normalizeText(heading.textContent);
        savedStates.set(section, { isExpanded, key });

        // 如果目前是展開的,就收合它
        if(isExpanded){
          body.classList.add('collapsed');
          section.classList.remove('expanded');
          heading.setAttribute('aria-expanded', 'false');
        }
      });

      updateRailVisibility(root);
    }

    function restoreAll(){
      if(!savedStates) return;

      savedStates.forEach((state, section) => {
        const body = section.querySelector('.section-body');
        const heading = section.querySelector('[role="heading"]');
        if(!body || !heading) return;

        // 恢復原本的狀態
        if(state.isExpanded){
          body.classList.remove('collapsed');
          section.classList.add('expanded');
          heading.setAttribute('aria-expanded', 'true');
        }
      });

      savedStates = null;
      updateRailVisibility(root);
    }

    // 清除記憶的函數
    function clearSavedStates(){
      if(savedStates && isCollapsedAll){
        savedStates = null;
        isCollapsedAll = false;
        collapseAllBtn.innerHTML = '&gt; &lt;';
      }
    }

    /* ===== 更穩定的「貼齊左側」實作 ===== */
    function scrollAlignLeftStable(el, margin = 0, maxTries = 12){
      if(!el || !mainWrap) return;
      if(mainWrap.scrollWidth <= mainWrap.clientWidth) return;

      try{
        el.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });
      }catch(_e){}

      let tries = 0;
      const step = () => {
        if(!el.isConnected) return;
        const style  = getComputedStyle(mainWrap);
        const padL   = parseFloat(style.scrollPaddingLeft || '0') + parseFloat(style.paddingLeft || '0') + margin;

        const wrapRect = mainWrap.getBoundingClientRect();
        const elRect   = el.getBoundingClientRect();
        const current  = mainWrap.scrollLeft;

        const targetLeftInWrap = elRect.left - wrapRect.left + current;
        const desired = Math.max(0, targetLeftInWrap - padL);

        const diff = Math.abs(mainWrap.scrollLeft - desired);

        if (diff <= 1 || tries >= maxTries){
          mainWrap.scrollLeft = desired;
          return;
        }

        mainWrap.scrollTo({ left: desired });
        tries++;
        requestAnimationFrame(step);
      };

      requestAnimationFrame(step);
    }

    /* 計算 li 的真實層級深度 */
    function listDepth(li){
      let depth = 0;
      let current = li.parentElement;
      while(current && current !== root){
        if(current.tagName === 'UL' || current.tagName === 'OL') depth++;
        current = current.parentElement;
      }
      return Math.max(0, depth - 1);
    }

    /* 取「第一層」子 section 的 heading */
    function getFirstChildHeading(sectionBody){
      let h = null;
      try{ h = sectionBody.querySelector(':scope > .section > [role="heading"]'); }catch(_e){}
      if (h) return h;
      return sectionBody.querySelector('.section > [role="heading"]');
    }

    /* 判斷一個容器是否「只有一張圖片」 */
    function isImageOnlyContainer(container){
      const kids = Array.from(container.childNodes).filter(n => {
        if(n.nodeType === 3) return !!n.textContent.trim();
        return n.nodeType === 1;
      });
      if(kids.length !== 1) return false;
      const el = kids[0];
      if(el.nodeType !== 1) return false;
      if(el.tagName === 'IMG') return true;
      if(el.tagName === 'P'){
        const pKids = Array.from(el.childNodes).filter(n => {
          if(n.nodeType === 3) return !!n.textContent.trim();
          return n.nodeType === 1;
        });
        return (pKids.length === 1 && pKids[0].nodeType === 1 && pKids[0].tagName === 'IMG');
      }
      return false;
    }

    /* ===== 高度動畫(0 ↔ 自適應)+ 導軌脈衝 + 標題柔光 ===== */
    function animateSection(bodyEl, expand=true, onDone){
      if(!bodyEl) { onDone && onDone(); return; }
      const parent = bodyEl.parentElement; // .section
      const reduce = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      const finish = ()=>{
        bodyEl.classList.remove('animating');
        bodyEl.style.height = '';
        bodyEl.style.opacity = '';
        if(!expand){
          bodyEl.classList.add('collapsed');
          parent.classList.remove('expanded');
        }
        onDone && onDone();
      };

      if(reduce){
        // 瞬切(無動畫)
        if(expand){
          bodyEl.classList.remove('collapsed');
          parent.classList.add('expanded');
        }else{
          bodyEl.classList.add('collapsed');
          parent.classList.remove('expanded');
        }
        finish();
        return;
      }

      if(expand){
        // 展開:先顯示再由 0 → scrollHeight
        bodyEl.classList.remove('collapsed');
        parent.classList.add('expanded');

        const targetH = bodyEl.scrollHeight; // 量測完成高度
        bodyEl.classList.add('animating');
        bodyEl.style.height = '0px';
        bodyEl.style.opacity = 0;

        requestAnimationFrame(()=>{
          bodyEl.style.height = targetH + 'px';
          bodyEl.style.opacity = 1;
        });

        bodyEl.addEventListener('transitionend', function te(e){
          if(e.propertyName === 'height'){ bodyEl.removeEventListener('transitionend', te); finish(); }
        });
      }else{
        // 收合:由 scrollHeight → 0
        const startH = bodyEl.scrollHeight;
        bodyEl.classList.add('animating');
        bodyEl.style.height = startH + 'px';
        bodyEl.style.opacity = 1;

        requestAnimationFrame(()=>{
          bodyEl.style.height = '0px';
          bodyEl.style.opacity = 0;
        });

        bodyEl.addEventListener('transitionend', function te(e){
          if(e.propertyName === 'height'){ bodyEl.removeEventListener('transitionend', te); finish(); }
        });
      }
    }

    function pulseRail(bodyEl){
      // 讓 :before 可以重新觸發動畫
      bodyEl.classList.remove('pulse');
      // 觸發重排
      void bodyEl.offsetWidth;
      bodyEl.classList.add('pulse');
    }
    function glowJustOpened(sectionEl){
      sectionEl.classList.add('just-opened');
      setTimeout(()=> sectionEl.classList.remove('just-opened'), 850);
    }

    /* li → .section, 並加入穩定貼左與動畫行為 + 圖片標題隱藏圓點 */
    function listsToSections(container, { defaultCollapsed=false }={}){
      const allLis = Array.from(container.querySelectorAll('li')).reverse();
      allLis.forEach(li=>{
        const depth = listDepth(li);
        const wrap  = document.createElement('div');
        wrap.className = 'section';
        wrap.style.setProperty('--depth', depth);

        const heading = document.createElement('div');
        heading.setAttribute('role','heading');
        heading.setAttribute('aria-level', String(Math.min(2 + depth, 7)));
        heading.setAttribute('tabindex', '0');

        const body = document.createElement('div');
        body.className = 'section-body';

        const fragHead = document.createDocumentFragment();
        const fragBody = document.createDocumentFragment();
        let n = li.firstChild, metList = false;
        while(n){
          const next = n.nextSibling;
          if(!metList && n.nodeType===1 && (n.tagName==='UL' || n.tagName==='OL')) metList = true;
          (metList ? fragBody : fragHead).appendChild(n);
          n = next;
        }
        if(!fragHead.childNodes.length){
          const span = document.createElement('span');
          span.textContent = '(空白節點)';
          fragHead.appendChild(span);
        }
        heading.appendChild(fragHead);
        body.appendChild(fragBody);

        wrap.appendChild(heading);
        wrap.appendChild(body);
        li.replaceWith(wrap);

        /* 若標題區只有圖片,為該節點加入 .image-heading(用 CSS 做影子收合) */
        if (isImageOnlyContainer(heading)) {
          wrap.classList.add('image-heading');
        }

        const hasChildren = !!body.querySelector('.section');
        wrap.classList.toggle('has-children', hasChildren);
        wrap.classList.toggle('is-leaf', !hasChildren);

        const key = 'fold:li:' + normalizeText(heading.textContent);
        const saved = loadState(key);
        const startCollapsed = (saved != null) ? saved : !!defaultCollapsed;
        if(startCollapsed){
          body.classList.add('collapsed');
          wrap.classList.remove('expanded');
        }else{
          wrap.classList.add('expanded');
        }
        heading.setAttribute('aria-expanded', String(!startCollapsed));

        const toggle = ()=>{
          const expanding = body.classList.contains('collapsed'); // 目前是收合 → 準備展開
          saveState(key, expanding);

          // 如果使用者手動展開節點,清除之前保存的收合全部記憶
          if(expanding && savedStates && isCollapsedAll){
            clearSavedStates();
          }

          // 在動畫開始前先記住當前點擊的標題位置
          const headingRect = heading.getBoundingClientRect();
          const wrapRect = mainWrap.getBoundingClientRect();
          const offsetBeforeAnimation = headingRect.top - wrapRect.top + mainWrap.scrollTop;

          animateSection(body, expanding, ()=>{
            heading.setAttribute('aria-expanded', String(expanding));
            wrap.classList.toggle('expanded', expanding);
            updateRailVisibility(container);

            // 動畫完成後，立即校正滾動位置
            // 使用兩個 requestAnimationFrame 確保 DOM 完全更新後再校正
            requestAnimationFrame(()=>{
              requestAnimationFrame(()=>{
                const currentHeadingRect = heading.getBoundingClientRect();
                const currentWrapRect = mainWrap.getBoundingClientRect();
                const currentOffset = currentHeadingRect.top - currentWrapRect.top + mainWrap.scrollTop;

                // 計算需要校正的距離
                const scrollCorrection = currentOffset - offsetBeforeAnimation;

                // 校正滾動位置，使標題保持在原來的視覺位置
                // 對於收合操作，需要更積極地校正
                if(Math.abs(scrollCorrection) > 0.5){
                  mainWrap.scrollTop = mainWrap.scrollTop - scrollCorrection;
                }

                // 然後再執行左對齊
                scrollAlignLeftStable(heading, 0);

                if (expanding){
                  const firstChildHeading = getFirstChildHeading(body) || heading;
                  requestAnimationFrame(()=> scrollAlignLeftStable(firstChildHeading, 0));
                  pulseRail(body);        // 導軌脈衝
                  glowJustOpened(wrap);   // 標題柔光
                }
              });
            });
          });
        };

        heading.addEventListener('click', toggle);
        heading.addEventListener('keydown', (e)=>{
          if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); toggle(); }
          if(e.key === 'ArrowRight' && body.classList.contains('collapsed')){ e.preventDefault(); toggle(); }
          if(e.key === 'ArrowLeft'  && !body.classList.contains('collapsed')){ e.preventDefault(); toggle(); }
        });
      });

      container.querySelectorAll('ul,ol').forEach(list=> list.classList.add('list-host'));

      const ro = new ResizeObserver(() => {
        const expandedHeadings = container.querySelectorAll('.section.expanded > [role="heading"]');
        expandedHeadings.forEach(h=>{
          const rect = h.getBoundingClientRect();
          const wrapRect = mainWrap.getBoundingClientRect();
          const outLeft = rect.left < wrapRect.left + 1;
          const outRight = rect.right > wrapRect.right - 1;
          if(outLeft || outRight){
            scrollAlignLeftStable(h, 0, 4);
          }
        });
      });
      ro.observe(mainWrap);
    }

    /* 將 ./images/* 或 images/* 改寫到 /content/images/* */
    function rewriteRelativeImages(container){
      const imgs = container.querySelectorAll('img');
      imgs.forEach(img=>{
        const src = img.getAttribute('src') || '';
        if (/^\/content\//i.test(src)) return;
        if (/^\.?\/?images\//i.test(src)) {
          const clean = src.replace(/^\.\//, '').replace(/^\/?images\//i, 'images/');
          img.setAttribute('src', '/content/' + clean);
        }
      });
    }

    /* 標記只有一張圖片的 li(轉換前的 <li> 用) */
    function markImageOnlyLis(container){
      const lis = container.querySelectorAll('li');
      lis.forEach(li=>{
        const kids = Array.from(li.childNodes).filter(n => !(n.nodeType===3 && !n.textContent.trim()));
        let onlyImg = false;
        if(kids.length === 1 && kids[0].nodeType === 1){
          const el = kids[0];
          if(el.tagName === 'IMG'){
            onlyImg = true;
          }else if(el.tagName === 'P'){
            const pKids = Array.from(el.childNodes).filter(n => !(n.nodeType===3 && !n.textContent.trim()));
            if(pKids.length === 1 && pKids[0].nodeType === 1 && pKids[0].tagName === 'IMG'){
              onlyImg = true;
            }
          }
        }
        if(onlyImg) li.classList.add('li-image-only');
      });
    }

    /* 標記純文字型清單項目(轉換前的 <li> 用) */
    function tagHeadingSizedLis(container){
      const lis = container.querySelectorAll('li');
      lis.forEach(li=>{
        const kids = Array.from(li.childNodes).filter(n => {
          if(n.nodeType === 3) return !!n.textContent.trim();
          return n.nodeType === 1;
        });
        const hasNoNestedList = !li.querySelector('ul,ol');
        const hasNoImg = !li.querySelector('img');
        if(kids.length === 1 && hasNoNestedList && hasNoImg){
          const el = kids[0];
          if(el.nodeType === 3 || (el.nodeType === 1 && !['IMG','UL','OL'].includes(el.tagName))){
            li.classList.add('li-as-heading');
          }
        }
      });
    }

    /* 更新導軌可見性 */
    function updateRailVisibility(container){
      const sections = container.querySelectorAll('.section');
      sections.forEach(s=>{
        const body = s.querySelector('.section-body');
        if(!body) return;
        const childSections = Array.from(body.children).filter(c => c.classList.contains('section'));
        const shouldHide = (childSections.length === 1);
        childSections.forEach(child=>{
          child.classList.toggle('no-rail', shouldHide);
        });
      });
    }

    /* 圖片全螢幕(縮放+拖曳+手機觸控支援) */
    function enableImageFullscreen(container){
      const overlay   = document.getElementById('imgOverlay');
      const viewport  = document.getElementById('imgViewport');
      const overlayImg= document.getElementById('imgOverlayImg');
      if(!overlay || !viewport || !overlayImg) return;

      let scale = 1, tx = 0, ty = 0, baseRect = null;
      const MIN_SCALE = 1, MAX_SCALE = 5;

      // 觸控相關變數
      let lastTouchDist = 0;
      let lastTouchCenter = { x: 0, y: 0 };
      let isDragging = false;
      let dragStartX = 0, dragStartY = 0;
      let dragStartTx = 0, dragStartTy = 0;

      function applyTransform(){ overlayImg.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`; }
      function resetTransform(){ scale = 1; tx = 0; ty = 0; applyTransform(); overlayImg.classList.remove('grabbable','grabbing'); overlay.style.cursor = 'zoom-out'; }
      function clampPan(){
        const vpW = viewport.clientWidth, vpH = viewport.clientHeight;
        const imgW = baseRect ? baseRect.width  : overlayImg.getBoundingClientRect().width / scale;
        const imgH = baseRect ? baseRect.height : overlayImg.getBoundingClientRect().height / scale;
        const scaledW = imgW * scale, scaledH = imgH * scale;
        const maxX = Math.max(0, (scaledW - vpW) / 2), maxY = Math.max(0, (scaledH - vpH) / 2);
        tx = maxX===0 ? 0 : Math.max(-maxX, Math.min(maxX, tx));
        ty = maxY===0 ? 0 : Math.max(-maxY, Math.min(maxY, ty));
      }

      function zoomAt(clientX, clientY, deltaY){
        const zoomFactor = Math.exp(-deltaY * 0.002);
        const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * zoomFactor));
        if(newScale === scale) return;
        const vpRect = viewport.getBoundingClientRect();
        const offsetX = clientX - (vpRect.left + vpRect.width/2);
        const offsetY = clientY - (vpRect.top  + vpRect.height/2);
        const imgToCursorX = offsetX - tx, imgToCursorY = offsetY - ty;
        const ratio = newScale / scale;
        tx = offsetX - imgToCursorX * ratio;
        ty = offsetY - imgToCursorY * ratio;
        scale = newScale;
        clampPan();
        applyTransform();
        if(scale > 1){ overlayImg.classList.add('grabbable'); overlay.style.cursor = 'default'; }
        else { overlayImg.classList.remove('grabbable','grabbing'); overlay.style.cursor = 'zoom-out'; }
      }

      // 計算兩點之間的距離
      function getTouchDistance(t1, t2){
        const dx = t1.clientX - t2.clientX;
        const dy = t1.clientY - t2.clientY;
        return Math.sqrt(dx * dx + dy * dy);
      }

      // 計算兩點的中心
      function getTouchCenter(t1, t2){
        return {
          x: (t1.clientX + t2.clientX) / 2,
          y: (t1.clientY + t2.clientY) / 2
        };
      }

      // 觸控開始
      overlayImg.addEventListener('touchstart', (e)=>{
        if(e.touches.length === 1 && scale > 1){
          // 單指拖曳(僅在放大時)
          isDragging = true;
          dragStartX = e.touches[0].clientX;
          dragStartY = e.touches[0].clientY;
          dragStartTx = tx;
          dragStartTy = ty;
          overlayImg.classList.add('grabbing');
        } else if(e.touches.length === 2){
          // 雙指縮放
          e.preventDefault();
          isDragging = false;
          lastTouchDist = getTouchDistance(e.touches[0], e.touches[1]);
          lastTouchCenter = getTouchCenter(e.touches[0], e.touches[1]);
        }
      }, { passive: false });

      // 觸控移動
      overlayImg.addEventListener('touchmove', (e)=>{
        if(e.touches.length === 1 && isDragging && scale > 1){
          e.preventDefault();
          const deltaX = e.touches[0].clientX - dragStartX;
          const deltaY = e.touches[0].clientY - dragStartY;
          tx = dragStartTx + deltaX;
          ty = dragStartTy + deltaY;
          clampPan();
          applyTransform();
        } else if(e.touches.length === 2){
          e.preventDefault();
          const newDist = getTouchDistance(e.touches[0], e.touches[1]);
          const newCenter = getTouchCenter(e.touches[0], e.touches[1]);
          const scaleDelta = newDist / lastTouchDist;
          const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * scaleDelta));

          if(newScale !== scale){
            const vpRect = viewport.getBoundingClientRect();
            const offsetX = newCenter.x - (vpRect.left + vpRect.width/2);
            const offsetY = newCenter.y - (vpRect.top  + vpRect.height/2);
            const imgToCursorX = offsetX - tx;
            const imgToCursorY = offsetY - ty;
            const ratio = newScale / scale;

            tx = offsetX - imgToCursorX * ratio;
            ty = offsetY - imgToCursorY * ratio;
            scale = newScale;
            clampPan();
            applyTransform();

            if(scale > 1){
              overlayImg.classList.add('grabbable');
              overlay.style.cursor = 'default';
            } else {
              overlayImg.classList.remove('grabbable','grabbing');
              overlay.style.cursor = 'zoom-out';
            }
          }

          lastTouchDist = newDist;
          lastTouchCenter = newCenter;
        }
      }, { passive: false });

      // 觸控結束
      overlayImg.addEventListener('touchend', (e)=>{
        if(isDragging){
          isDragging = false;
          overlayImg.classList.remove('grabbing');
        }
        if(e.touches.length === 0){
          lastTouchDist = 0;
        }
      });

      // 滑鼠拖曳(PC)
      let isMouseDragging = false;
      overlayImg.addEventListener('mousedown', (e)=>{
        if(scale > 1 && e.button === 0){
          isMouseDragging = true;
          dragStartX = e.clientX;
          dragStartY = e.clientY;
          dragStartTx = tx;
          dragStartTy = ty;
          overlayImg.classList.add('grabbing');
          e.preventDefault();
        }
      });

      document.addEventListener('mousemove', (e)=>{
        if(isMouseDragging){
          const deltaX = e.clientX - dragStartX;
          const deltaY = e.clientY - dragStartY;
          tx = dragStartTx + deltaX;
          ty = dragStartTy + deltaY;
          clampPan();
          applyTransform();
        }
      });

      document.addEventListener('mouseup', ()=>{
        if(isMouseDragging){
          isMouseDragging = false;
          overlayImg.classList.remove('grabbing');
        }
      });

      container.addEventListener('click', (e)=>{ const img = e.target.closest('img'); if(img) openOverlay(img); });
      function openOverlay(img){
        overlayImg.src = img.currentSrc || img.src; overlayImg.alt = img.alt || '';
        overlay.classList.add('open'); overlay.setAttribute('aria-hidden', 'false'); document.body.style.overflow = 'hidden';
        if(overlayImg.complete){ baseRect = overlayImg.getBoundingClientRect(); } else { overlayImg.onload = ()=>{ baseRect = overlayImg.getBoundingClientRect(); }; }
        resetTransform();
      }
      function closeOverlay(){
        overlay.classList.remove('open'); overlay.setAttribute('aria-hidden', 'true');
        overlayImg.src = ''; document.body.style.overflow = '';
        isDragging = false;
        isMouseDragging = false;
        overlayImg.classList.remove('grabbing');
      }
      overlay.addEventListener('click', (e)=>{ if(e.target === overlay || e.target === viewport) closeOverlay(); });
      window.addEventListener('keydown', (e)=>{ if(e.key === 'Escape' && overlay.classList.contains('open')) closeOverlay(); });
      overlay.addEventListener('wheel', (e)=>{ e.preventDefault(); const dy = e.deltaY * (e.ctrlKey ? 0.5 : 1); zoomAt(e.clientX, e.clientY, dy); }, { passive: false });
      overlayImg.addEventListener('dblclick', (e)=>{ e.preventDefault(); if(scale === 1){ const fakeDelta = Math.log(2/scale)/(-0.002); zoomAt(e.clientX, e.clientY, fakeDelta); } else { resetTransform(); } });
    }

    /* Frontmatter 解析 */
    function parseFrontmatter(src){
      if(src.charCodeAt(0) === 0xFEFF) src = src.slice(1);
      const m = src.match(/^---\s*[\r\n]([\s\S]*?)\r?\n---\s*[\r\n]([\s\S]*)$/);
      if(m) return { meta: yamlToJSON(m[1]), body: m[2] };
      return { meta:{}, body: src };
    }
    function yamlToJSON(yaml){
      const out = {};
      yaml.split(/\r?\n/).forEach(line=>{
        if(!line.trim() || line.trim().startsWith('#')) return;
        const i = line.indexOf(':'); if(i<1) return;
        const k = line.slice(0,i).trim();
        let v = line.slice(i+1).trim();
        if((v.startsWith('"') && v.endsWith('"'))||(v.startsWith("'") && v.endsWith("'"))) v=v.slice(1,-1);
        out[k]=v;
      });
      return out;
    }

    /* 狀態保存 */
    function saveState(key, val){ try{ localStorage.setItem(key, JSON.stringify(!!val)); }catch(e){} }
    function loadState(key){
      try{
        const v = localStorage.getItem(key);
        return v==null ? null : JSON.parse(v);
      }catch(e){ return null; }
    }
    function normalizeText(s){ return (s||'').replace(/\s+/g,'').trim(); }

    function showError(msg){
      root.innerHTML = '<pre style="white-space:pre-wrap;background:#0001;padding:12px;border-radius:8px">'+msg+'</pre>';
    }
  })();
  </script>
</body>
</html>